{% extends "layouts/regular.html" %}
{% from "macros/macros.html" import fractal, navbar %}

{% block content %}
    <section class="generate">
        <h1 class="generate__title hitbox">{{ title }}</h1>
        <form action="{{ url_for("generate") }}" method="get">

            <input aria-label="Fractal Seed"
                   name="seed" type="text"
                   placeholder="Enter a seed..."
                   class="generate_input hitbox">
        </form>
        <canvas id="bubbles-canvas"></canvas>
        <canvas id="hidden-canvas"></canvas>
    </section>

    <script async defer>
    'use strict';

    class Vec2 {
        constructor(x, y) {
            this.x = x
            this.y = y
        }

        static fromPolar(angle, norm) {
            return new Vec2(Math.cos(angle) * norm, Math.sin(angle) * norm)
        }

        add(other) {
            return new Vec2(this.x + other.x, this.y + other.y)
        }
        radd(other) {
            this.x += other.x
            this.y += other.y
            return this
        }
        mult(scalar) {
            return new Vec2(this.x * scalar, this.y * scalar)
        }
        dividedBy(scalar) {
            return new Vec2(this.x / scalar, this.y / scalar)
        }
        to(other) {
            return new Vec2(other.x - this.x, other.y - this.y)
        }

        dot(other) {
            return this.x * other.x + this.y * other.y
        }
        norm2() {
            return this.x * this.x + this.y * this.y
        }
        norm() {
            return Math.sqrt(this.norm2())
        }
        eq(other) {
            return this.x === other.x && this.y === other.y
        }

        toString() {
            return `Vec2(${this.x}, ${this.y})`
        }
    }

    class Bubble {
        /**
         * A Fancy bubble.
         *
         * @param {Vec2} pos
         * @param {Vec2} vel
         * @param {int} radius
         */
        constructor(pos, vel, radius) {
            this.pos = pos;
            this.vel = vel;
            this.radius = radius;
            this.inv_mass = 1 / (radius * radius)

            this.img = null
            this.setBubbleImage()
        }
        collideBorders() {
            if (this.pos.x - this.radius <= 0 && this.vel.x < 0) {
                this.vel.x = -this.vel.x
            } else if (this.pos.x + this.radius >= window.innerWidth && this.vel.x > 0 ) {
                this.vel.x = -this.vel.x
            }

            if (this.pos.y - this.radius <= 0 && this.vel.y < 0) {
                this.vel.y = -this.vel.y
            } else if (this.pos.y + this.radius >= window.innerHeight && this.vel.y > 0) {
                this.vel.y = -this.vel.y
            }
        }
        collideBubble(other) {
            let dist = this.pos.to(other.pos)
            const dist2 = dist.norm2()
            if (dist2 >= (this.radius + other.radius)**2) {
                // No collisions
                return
            }

            const d = Math.sqrt(dist2)
            let normal, penetration
            if (dist2 !== 0.0) {
                penetration = this.radius + other.radius - d
                normal = dist.dividedBy(d)
            } else {
                penetration = this.radius
                normal = new Vec2(0, 1)
            }

            return new Collision(this, other, normal, penetration)
        }
        collideRect(rect) {
            // Find the closest point to the circle within the rectangle
            const closest = new Vec2(
                clamp(this.pos.x, rect.min.x, rect.max.x),
                clamp(this.pos.y, rect.min.y, rect.max.y)
            )

            // Calculate the distance between the circle's center and this closest point
            let d = closest.to(this.pos)

            // If the distance is less than the circle's radius, an intersection occurs
            const norm2 = d.norm2()
            if (norm2 >= (this.radius * this.radius)) {
                return
            }

            const norm = Math.sqrt(norm2)

            if (closest.eq(this.pos)) {
                console.log(this, rect)
                // Circle is inside the AABB, so we need to clamp the circle's center
                // to the closest edge

                const left = this.pos.x - rect.min.x
                const top = this.pos.y - rect.min.y
                const right = rect.max.x - this.pos.x
                const bottom = rect.max.y - this.pos.y

                const mini = Math.min(left, top, right, bottom)
                if (mini === left) {
                    closest.x = rect.min.x
                } else if (mini === right) {
                    closest.x = rect.max.x
                } else if (mini === top) {
                    closest.y = rect.min.y
                } else if (mini === bottom) {
                    closest.y = rect.max.y
                }

                const normal = this.pos.to(closest)

                const n = normal.norm();
                return new Collision(this, rect, normal.dividedBy(-n), this.radius - n)
            } else {
                return new Collision(this, rect, d.dividedBy(-norm), this.radius - norm);
            }
        }

        setBubbleImage() {
            this.img = new Image()
            this.img.addEventListener("load", () => {
                console.log(1)
                canvasHidden.width = 2 * this.radius
                canvasHidden.height = 2 * this.radius
                const grad = ctxHidden.createRadialGradient(
                    this.radius, this.radius, this.radius/2,
                    this.radius, this.radius, this.radius,
                )
                grad.addColorStop(0.8, "#fff")
                grad.addColorStop(1.0, "rgba(255, 255, 255, 0)")
                ctxHidden.save()
                ctxHidden.fillStyle = grad
                ctxHidden.fillRect(0, 0, canvasHidden.width, canvasHidden.height)
                ctxHidden.globalCompositeOperation = "source-in"
                const sh = this.img.height
                const sx = (this.img.width - sh) / 2
                ctxHidden.drawImage(this.img, sx, 0, sh, sh, 0, 0, this.radius * 2, this.radius * 2)
                ctxHidden.restore()
                this.img.src = canvasHidden.toDataURL("image/png")
                console.log(this.img.src)
            }, {once: true})
            const seed = Math.floor(randRange(0, 1000))
            this.img.src = `{{ url_for("img", size=200, seed="${seed}") }}`

        }
        render(ctx) {
            ctx.drawImage(this.img, this.pos.x - this.radius, this.pos.y - this.radius)
        }
    }

    class Rect {
        /**
         * An AABB.
         * @param min
         * @param max
         */
        constructor(min, max) {
            this.min = min
            this.max = max
            this.inv_mass = 0
            this.vel = new Vec2(0, 0)
        }
    }

    class Collision {
        constructor(objA, objB, normal, penetration) {
            this.objA = objA;
            this.objB = objB;
            this.normal = normal;
            this.penetration = penetration;
        }
        resolve() {
            const velRelative = this.objA.vel.to(this.objB.vel)
            const velAlongNormal = velRelative.dot(this.normal)

            if (velAlongNormal > 0) {
                return
            }

            const j = -2 * velAlongNormal / (this.objA.inv_mass + this.objB.inv_mass)
            const impulse = this.normal.mult(j)
            this.objA.vel.radd(impulse.mult(-this.objA.inv_mass))
            this.objB.vel.radd(impulse.mult(this.objB.inv_mass))
        }
    }

    let nb = 40
    let bubbles = []
    let hitboxes = []
    const canvasHidden = document.getElementById("hidden-canvas")
    const ctxHidden = canvasHidden.getContext("2d")
    const canvas = document.getElementById("bubbles-canvas")
    const ctx = canvas.getContext("2d")

    const clamp = (x, min, max) => x < min ? min : x > max ? max : x
    const randRange = (min, max) => Math.random() * (max - min) + min

    const create = (left) => {
        const radius = randRange(15, 35)
        const pos = new Vec2(
            left ? -radius -10 : window.innerWidth + radius + 10,
            window.innerHeight + radius + 10
        )
        const vel = Vec2.fromPolar(
            randRange(1/6, 2/6) * Math.PI,
            randRange(90, 140)
        )

        bubbles.push(new Bubble(pos, vel, radius))
    }

    const spawn = () => {
        if (nb <= 0) {
            clearInterval(i)
        } else {
            create(true)
            create(false)
            --nb
            --nb
        }
    }
    const i = setInterval(spawn, 1000)

    // Find rects of all .hitbox elements
    const set_rects = () => {
        hitboxes = []
        document
            .querySelectorAll(".hitbox")
            .forEach(h => {
                let r = h.getBoundingClientRect()
                hitboxes.push(new Rect(
                    new Vec2(r.left, r.top),
                    new Vec2(r.left + r.width, r.top + r.height)
                ))
            })

        canvas.width = window.innerWidth
        canvas.height =  window.innerHeight
    }
    window.addEventListener("resize", set_rects)


    const update = (dt) => {
                for (const bubble of bubbles) {
            bubble.pos = bubble.pos.add(bubble.vel.mult(dt))
            bubble.collideBorders()
        }

        let collisions = []
        bubbles.forEach((b1, idx1) => {
            bubbles.forEach((b2, idx2) => {
                if (idx2 > idx1) {
                    const col = b1.collideBubble(b2)
                    if (col) {
                        collisions.push(col)
                    }
                }
            })

            hitboxes.forEach(hitbox => {
                const col = b1.collideRect(hitbox)
                if (col) {
                    collisions.push(col)
                }
            })
        })
        collisions.forEach(col => {
            col.resolve()
        })

        for (const b of bubbles) {
            if (b.pos.x != b.pos.x) {
                console.log(b)
                debugger;
                return
            }
        }
    }

    const render = () => {
        ctx.fillStyle = "rgba(0, 0, 0, 0)"
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        bubbles.forEach(bubble => bubble.render(ctx))
    }

    let last = performance.now()
    const animation = (now) => {
        const dt = Math.min(0.1, (now - last) / 1000)
        update(dt)
        render()

        last = now
        requestAnimationFrame(animation)
    }

    set_rects()
    requestAnimationFrame(animation)

    </script>

{% endblock %}
