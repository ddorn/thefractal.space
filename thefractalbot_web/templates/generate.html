{% extends "layouts/regular.html" %}
{% from "macros/macros.html" import fractal, navbar %}

{% block content %}
    <section class="generate">
        <h1 class="generate__title hitbox">{{ title }}</h1>
        <form action="{{ url_for("generate") }}" method="get">

            <input aria-label="Fractal Seed"
                   name="seed" type="text"
                   placeholder="Enter a seed..."
                   class="generate_input hitbox">
        </form>
    </section>

    <script async defer>
    'use strict';

    class Vec2 {
        constructor(x, y) {
            this.x = x
            this.y = y
        }

        static fromPolar(angle, norm) {
            return new Vec2(Math.cos(angle) * norm, Math.sin(angle) * norm)
        }

        add(other) {
            return new Vec2(this.x + other.x, this.y + other.y)
        }
        radd(other) {
            this.x += other.x
            this.y += other.y
            return this
        }
        mult(scalar) {
            return new Vec2(this.x * scalar, this.y * scalar)
        }
        dividedBy(scalar) {
            return new Vec2(this.x / scalar, this.y / scalar)
        }
        to(other) {
            return new Vec2(other.x - this.x, other.y - this.y)
        }

        dot(other) {
            return this.x * other.x + this.y * other.y
        }
        norm2() {
            return this.x * this.x + this.y * this.y
        }
        norm() {
            return Math.sqrt(this.norm2())
        }
        eq(other) {
            return this.x === other.x && this.y === other.y
        }

        toString() {
            return `Vec2(${this.x}, ${this.y})`
        }
    }

    class Bubble {
        /**
         * A Fancy bubble.
         *
         * @param {Vec2} pos
         * @param {Vec2} vel
         * @param {int} radius
         * @param {Element} el
         */
        constructor(pos, vel, radius, el) {
            this.pos = pos;
            this.vel = vel;
            this.radius = radius;
            this.el = el;
            this.inv_mass = 1 / (radius * radius)
        }
        collideBorders() {

            if (this.pos.x - this.radius <= 0) {
                this.pos.x = this.radius
                this.vel.x = -this.vel.x
            } else if (this.pos.x + this.radius >= window.innerWidth ) {
                this.pos.x = window.innerWidth - this.radius
                this.vel.x = -this.vel.x
            }

            if (this.pos.y - this.radius <= 0) {
                this.pos.y = this.radius
                this.vel.y = -this.vel.y
            } else if (this.pos.y + this.radius >= window.innerHeight ) {
                this.pos.y = window.innerHeight - this.radius
                this.vel.y = -this.vel.y
            }
        }
        collideBubble(other) {
            let dist = this.pos.to(other.pos)
            const dist2 = dist.norm2()
            if (dist2 >= (this.radius + other.radius)**2) {
                // No collisions
                return
            }

            const d = Math.sqrt(dist2)
            let normal, penetration
            if (dist2 !== 0.0) {
                penetration = this.radius + other.radius - d
                normal = dist.dividedBy(d)
            } else {
                penetration = this.radius
                normal = new Vec2(0, 1)
            }

            return new Collision(this, other, normal, penetration)

/*
            // From https://en.wikipedia.org/wiki/Elastic_collision#Two-dimensional_collision_with_two_moving_objects
            const coef = 2.0 / (b1.mass + b2.mass)
            const axial = velRelative.dot(dist)
            const coef_tot = coef * axial / dist2
            b1.vx = b1.vx - b2.mass * coef_tot * -dx
            b1.vy = b1.vy - b2.mass * coef_tot * -dy
            b2.vx = b2.vx - b1.mass * coef_tot * dx
            b2.vy = b2.vy - b1.mass * coef_tot * dy


            // p1 = p2 + (r1+r2)*D
            const dist = Math.sqrt(dist2)
            b1.x = b2.x - (b1.hs + b2.hs) * dx / dist
            b1.y = b2.y - (b1.hs + b2.hs) * dy / dist
 */


            {#dist = Math.sqrt(dist2)#}
            {#b2.x = b1.x + dx / dist * (b1.size + b2.size) / 2#}
            {#b2.y = b1.y + dy / dist * (b1.size + b2.size) / 2#}

        }
        collideRect(rect) {
            // Find the closest point to the circle within the rectangle
            const closest = new Vec2(
                clamp(this.pos.x, rect.min.x, rect.max.x),
                clamp(this.pos.y, rect.min.y, rect.max.y)
            )

            // Calculate the distance between the circle's center and this closest point
            let d = closest.to(this.pos)

            // If the distance is less than the circle's radius, an intersection occurs
            const norm2 = d.norm2()
            if (norm2 >= (this.radius * this.radius)) {
                return
            }

            const norm = Math.sqrt(norm2)

            if (closest.eq(this.pos)) {
                console.log(this, rect)
                // Circle is inside the AABB, so we need to clamp the circle's center
                // to the closest edge

                const left = this.pos.x - rect.min.x
                const top = this.pos.y - rect.min.y
                const right = rect.max.x - this.pos.x
                const bottom = rect.max.y - this.pos.y

                const mini = Math.min(left, top, right, bottom)
                if (mini === left) {
                    closest.x = rect.min.x
                } else if (mini === right) {
                    closest.x = rect.max.x
                } else if (mini === top) {
                    closest.y = rect.min.y
                } else if (mini === bottom) {
                    closest.y = rect.max.y
                }

                const normal = this.pos.to(closest)

                const n = normal.norm();
                return new Collision(this, rect, normal.dividedBy(-n), this.radius - n)
            } else {
                return new Collision(this, rect, d.dividedBy(-norm), this.radius - norm);
            }
        }
    }

    class Rect {
        /**
         * An AABB.
         * @param min
         * @param max
         */
        constructor(min, max) {
            this.min = min
            this.max = max
            this.inv_mass = 0
            this.vel = new Vec2(0, 0)
        }
    }

    class Collision {
        constructor(objA, objB, normal, penetration) {
            this.objA = objA;
            this.objB = objB;
            this.normal = normal;
            this.penetration = penetration;
        }
        resolve() {
            const velRelative = this.objA.vel.to(this.objB.vel)
            const velAlongNormal = velRelative.dot(this.normal)

            if (velAlongNormal > 0) {
                return
            }

            const j = -2 * velAlongNormal / (this.objA.inv_mass + this.objB.inv_mass)
            const impulse = this.normal.mult(j)
            this.objA.vel.radd(impulse.mult(-this.objA.inv_mass))
            this.objB.vel.radd(impulse.mult(this.objB.inv_mass))
        }
    }

    const radius = 25
    const nb = 40
    let bubbles = []

    const px = int => `${int | 0}px`
    const clamp = (x, min, max) => x < min ? min : x > max ? max : x
    const randRange = (min, max) => Math.random() * (max - min) + min

    const create = () => {
        const radius = randRange(15, 35)
        const pos = new Vec2(
            randRange(radius, window.innerWidth - radius),
            randRange(radius, window.innerHeight - radius)
        )
        const vel = Vec2.fromPolar(
            Math.random() * 2 * Math.PI,
            randRange(60, 140)
        )

        let bubble = document.createElement("div")
        const img_id = Math.floor(Math.random() * 1000)
        bubble.innerHTML = `
            <div class="container--overlay">
                {{ fractal("${img_id}", class="generate__fractal", img_class="gen__img") }}
                <div class="overlay"></div>
            </div>
        `
        bubble.classList.add("bubble")
        bubble.style.top = px(pos.y - radius)
        bubble.style.left = px(pos.x - radius)
        bubble.style.width = px(radius * 2)
        bubble.style.height = px(radius * 2)

        document.body.appendChild(bubble)

        bubbles.push(new Bubble(pos, vel, radius, bubble))
    }

    let last = performance.now()
    const update_better = (now) => {
        for (const bubble of bubbles) {
            bubble.pos = bubble.pos.add(bubble.vel.mult((now - last) / 1000))
            bubble.collideBorders()
        }

        let collisions = []
        bubbles.forEach((b1, idx1) => {
            bubbles.forEach((b2, idx2) => {
                if (idx2 > idx1) {
                    const col = b1.collideBubble(b2)
                    if (col) {
                        collisions.push(col)
                    }
                }
            })

            hitboxes.forEach(hitbox => {
                const col = b1.collideRect(hitbox)
                if (col) {
                    collisions.push(col)
                }
            })
        })
        collisions.forEach(col => {
            col.resolve()
        })


        for (const b of bubbles) {
            if (b.pos.x != b.pos.x) {
                console.log(b)
                debugger;
                return
            }
        }

        bubbles.forEach(bubble => {
            bubble.el.style.top = px(bubble.pos.y - bubble.radius)
            bubble.el.style.left = px(bubble.pos.x - bubble.radius)
        })



        last = now
        requestAnimationFrame(update_better)
    }



    for (let i = 0; i < nb; i++) {
        create()
    }

    // Find rects of all .hitbox elements
    let hitboxes = []
    const find_hitboxes = () => {
        hitboxes = []
        document
            .querySelectorAll(".hitbox")
            .forEach(h => {
                let r = h.getBoundingClientRect()
                hitboxes.push(new Rect(
                    new Vec2(r.left, r.top),
                    new Vec2(r.left + r.width, r.top + r.height)
                ))
            })
    }
    window.addEventListener("resize", find_hitboxes)
    find_hitboxes()

    requestAnimationFrame(update_better)

    </script>

{% endblock %}
